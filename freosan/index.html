<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FREOSAN</title>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Sans:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050505;
            --text-color: #e0e0e0;
            --accent-color: #a0a0a0;
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Josefin Sans', sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 24px;
            z-index: 10;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: auto;
        }

        .title-block {
            position: fixed;
            top: 24px;
            left: 24px;
            transform: none;
            text-align: left;
            opacity: 0.8;
            z-index: 1000;
            pointer-events: none;
        }

        .title {
            font-weight: 600;
            font-size: 18px;
            letter-spacing: 6px;
            margin-bottom: 4px;
        }

        .subtitle {
            font-weight: 300;
            font-size: 10px;
            letter-spacing: 2px;
            color: var(--accent-color);
            text-transform: uppercase;
        }

        .load-btn {
            position: fixed;
            top: 24px;
            right: 24px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: var(--text-color);
            padding: 8px 16px;
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            letter-spacing: 2px;
            cursor: pointer;
            text-transform: uppercase;
            backdrop-filter: blur(4px);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .load-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #fff;
        }

        .controls-container {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 20px;
            pointer-events: auto;
            transition: opacity 0.3s ease;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent-color);
            width: 60px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 2px;
            background: #333;
            border-radius: 2px;
            outline: none;
            flex: 1;
            margin: 0 12px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .value {
            font-size: 10px;
            width: 30px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 5, 0.9);
            backdrop-filter: blur(20px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.8s ease;
        }

        .start-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 16px 32px;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .start-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #file-input {
            display: none;
        }

        .status-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            text-transform: uppercase;
        }

        .status-indicator.visible {
            opacity: 0.6;
        }
    </style>
</head>

<body>

    <canvas id="glCanvas"></canvas>

    <div id="nav-buttons"
        style="position: fixed; top: 16px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 10000; pointer-events: auto;">
        <button class="nav-btn" onclick="window.location.href='../index.html'"
            style="background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1); color: #fff; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-family: inherit; font-size: 14px; font-weight: 600; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); transition: all 0.2s;">M</button>
        <button class="nav-btn" onclick="randomApp()"
            style="background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1); color: #fff; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-family: inherit; font-size: 14px; font-weight: 600; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); transition: all 0.2s;">R</button>
    </div>

    <div class="ui-layer">
        <div class="header">
            <div class="title-block">
                <div class="title">FREOSAN</div>
                <div class="subtitle" id="track-name">GRANULAR SYNTHESISER PAD</div>
            </div>
            <button class="load-btn" onclick="document.getElementById('file-input').click()">Load Audio</button>
            <input type="file" id="file-input"
                accept="audio/mpeg, audio/wav, audio/ogg, audio/mp4, audio/webm, .mp3, .wav, .ogg, .m4a, .webm, .opus">
        </div>

        <div class="status-indicator" id="status-text">HOLD TO FREEZE</div>

        <div class="controls-container">
            <div class="control-row">
                <span class="label">Density</span>
                <input type="range" id="param-density" min="0" max="100" value="70">
                <span class="value" id="val-density">70</span>
            </div>
            <div class="control-row">
                <span class="label">Length</span>
                <input type="range" id="param-size" min="0" max="100" value="40">
                <span class="value" id="val-size">40</span>
            </div>
            <div class="control-row">
                <span class="label">Jitter</span>
                <input type="range" id="param-spray" min="0" max="100" value="20">
                <span class="value" id="val-spray">20</span>
            </div>
        </div>
    </div>

    <div id="start-overlay">
        <div style="margin-bottom: 20px; opacity: 0.7; font-size: 11px; letter-spacing: 1px;">HEADPHONES RECOMMENDED
        </div>
        <button class="start-btn" id="start-btn">INITIALISE</button>
    </div>

    <script>
        const CONFIG = { grainCount: 64, bufferDuration: 10 };

        let state = {
            isPlaying: false,
            isTouching: false,
            touchX: 0.5,
            touchY: 0.5,
            params: { density: 0.7, size: 0.4, spray: 0.2 }
        };

        const Audio = {
            ctx: null, master: null, masterFilter: null, highPass: null, highShelf: null,
            compressor: null, reverb: null, buffer: null, grains: [], inputGain: 1.0,

            init: function () {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();

                this.master = this.ctx.createGain();
                this.master.gain.value = 0.4;

                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -6;
                this.limiter.knee.value = 0;
                this.limiter.ratio.value = 20;
                this.limiter.attack.value = 0.0005;
                this.limiter.release.value = 0.05;

                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -18;
                this.compressor.knee.value = 10;
                this.compressor.ratio.value = 4;
                this.compressor.attack.value = 0.01;
                this.compressor.release.value = 0.15;

                this.highPass = this.ctx.createBiquadFilter();
                this.highPass.type = 'highpass';
                this.highPass.frequency.value = 40;

                this.masterFilter = this.ctx.createBiquadFilter();
                this.masterFilter.type = 'lowpass';
                this.masterFilter.frequency.value = 20000;
                this.masterFilter.Q.value = 0.5;

                this.highShelf = this.ctx.createBiquadFilter();
                this.highShelf.type = 'highshelf';
                this.highShelf.frequency.value = 4000;
                this.highShelf.gain.value = 3;

                this.reverb = this.ctx.createConvolver();
                this.reverb.buffer = this.generateImpulse(2.5);

                this.dryGain = this.ctx.createGain();
                this.dryGain.gain.value = 0.3;

                this.wetGain = this.ctx.createGain();
                this.wetGain.gain.value = 0.7;

                this.reverb.connect(this.wetGain);
                this.wetGain.connect(this.highPass);
                this.dryGain.connect(this.highPass);
                this.highPass.connect(this.masterFilter);
                this.masterFilter.connect(this.highShelf);
                this.highShelf.connect(this.compressor);
                this.compressor.connect(this.limiter);
                this.limiter.connect(this.master);
                this.master.connect(this.ctx.destination);

                this.buffer = this.generateDroneBuffer();

                // Load initial sample
                fetch('../Audiofiles/Harpnotes.m4a')
                    .then(response => response.arrayBuffer())
                    .then(buffer => this.loadBuffer(buffer))
                    .catch(err => console.error("Error loading Harpnotes:", err));

                for (let i = 0; i < CONFIG.grainCount; i++) {
                    this.grains.push(new Grain(this.ctx, this.reverb, this.dryGain, this.buffer));
                }
                this.schedule();
            },

            updateFilter: function (y) {
                if (!this.masterFilter) return;

                let effectiveY = y;
                if (effectiveY < 0.3) effectiveY = 0;
                else effectiveY = (effectiveY - 0.3) / 0.7;

                const minFreq = 200, maxFreq = 20000;
                const normY = 1.0 - effectiveY;
                const freq = minFreq * Math.pow(maxFreq / minFreq, normY);

                this.masterFilter.frequency.setTargetAtTime(freq, this.ctx.currentTime, 0.05);
            },

            generateImpulse: function (duration) {
                const rate = this.ctx.sampleRate, length = rate * duration;
                const impulse = this.ctx.createBuffer(2, length, rate);
                for (let i = 0; i < length; i++) {
                    const decay = Math.pow(1 - i / length, 4);
                    impulse.getChannelData(0)[i] = (Math.random() * 2 - 1) * decay;
                    impulse.getChannelData(1)[i] = (Math.random() * 2 - 1) * decay;
                }
                return impulse;
            },

            generateDroneBuffer: function () {
                const rate = this.ctx.sampleRate, length = rate * 10;
                const buff = this.ctx.createBuffer(2, length, rate);
                for (let c = 0; c < 2; c++) {
                    const data = buff.getChannelData(c);
                    for (let i = 0; i < length; i++) {
                        const t = i / rate;
                        data[i] = Math.sin(2 * Math.PI * 110 * t) * 0.1 + Math.sin(2 * Math.PI * 165 * t) * 0.05;
                    }
                }
                return buff;
            },

            loadBuffer: function (arrayBuffer) {
                this.ctx.decodeAudioData(arrayBuffer).then((decoded) => {
                    this.buffer = decoded;
                    this.inputGain = this.calcNormGain(decoded);
                    console.log("Audio loaded:", decoded.duration.toFixed(2), "s, normalization gain:", this.inputGain.toFixed(2));
                    this.grains.forEach(g => g.buffer = decoded);
                }).catch((err) => {
                    console.error("Error decoding audio data", err);
                    const msg = "Could not decode audio file.\n\nSupported formats:\nâ€¢ MP3, WAV, OGG, M4A, WebM\n\nAIFF/AIF files are NOT supported in Chrome/Firefox/Edge.\nConvert to WAV or MP3 first.";
                    alert(msg);
                });
            },

            calcNormGain: function (buffer) {
                const targetRMS = 0.2;
                let sumSq = 0, count = 0;

                for (let c = 0; c < buffer.numberOfChannels; c++) {
                    const data = buffer.getChannelData(c);
                    for (let i = 0; i < data.length; i += 100) {
                        sumSq += data[i] * data[i];
                        count++;
                    }
                }

                const rms = Math.sqrt(sumSq / count);
                if (rms < 0.001) return 1.0;

                let gain = targetRMS / rms;
                gain = Math.max(0.5, Math.min(gain, 8.0));
                return gain;
            },

            schedule: function () {
                if (!state.isPlaying) return;
                requestAnimationFrame(() => this.schedule());
            },

            triggerGrain: function (particle) {
                const grain = this.grains[Math.floor(Math.random() * this.grains.length)];
                const pan = particle.x / window.innerWidth;

                let offset, duration, gainMult;

                if (state.isTouching) {
                    const jitter = (Math.random() - 0.5) * state.params.spray * 0.1;
                    offset = (state.touchX * this.buffer.duration) + jitter;
                    duration = 0.1 + (state.params.size * 0.3);
                    gainMult = 0.8;
                } else {
                    offset = (particle.x / window.innerWidth) * this.buffer.duration;
                    duration = 0.2 + (state.params.size * 0.5);
                    gainMult = 0.8;
                }

                offset = Math.max(0, offset % this.buffer.duration);
                grain.play(offset, duration, 1.0, pan, gainMult);
            }
        };

        class Grain {
            constructor(ctx, wetDest, dryDest, buffer) {
                this.ctx = ctx; this.wetDest = wetDest; this.dryDest = dryDest; this.buffer = buffer;
            }

            play(offset, duration, rate, panVal, gainMult) {
                const now = this.ctx.currentTime;
                const src = this.ctx.createBufferSource();
                src.buffer = this.buffer;
                src.playbackRate.value = rate;

                const env = this.ctx.createGain();
                env.gain.value = 0;

                const panner = this.ctx.createStereoPanner();
                panner.pan.value = (panVal * 2) - 1;

                src.connect(env);
                env.connect(panner);
                panner.connect(this.wetDest);
                panner.connect(this.dryDest);

                const peakGain = gainMult * state.params.density * 0.15 * Audio.inputGain;
                env.gain.setValueAtTime(0, now);
                env.gain.linearRampToValueAtTime(peakGain, now + 0.01);
                env.gain.linearRampToValueAtTime(0, now + duration);

                src.start(now, offset);
                src.stop(now + duration + 0.1);

                setTimeout(() => { src.disconnect(); env.disconnect(); panner.disconnect(); }, (duration + 0.2) * 1000);
            }
        }

        const Canvas = {
            el: null, ctx: null, width: 0, height: 0, particles: [],

            init: function () {
                this.el = document.getElementById('glCanvas');
                this.ctx = this.el.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                for (let i = 0; i < CONFIG.grainCount; i++) {
                    this.particles.push(new VisualGrain(this.width, this.height));
                }
                this.loop();
            },

            resize: function () {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.el.width = this.width;
                this.el.height = this.height;
            },

            loop: function () {
                const filterY = state.isTouching ? state.touchY : 0;
                let effectiveBlurY = filterY < 0.3 ? 0 : (filterY - 0.3) / 0.7;
                const blurAmount = effectiveBlurY * 10;

                this.ctx.fillStyle = `rgba(5, 5, 5, ${0.2 + (effectiveBlurY * 0.3)})`;
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.particles.forEach(p => {
                    p.update(state.isTouching, state.touchX, state.touchY);
                    p.draw(this.ctx, blurAmount);

                    if (Math.random() < (state.params.density * 0.05)) {
                        Audio.triggerGrain(p);
                        p.pulse();
                    }
                });

                Audio.updateFilter(state.isTouching ? state.touchY : 0);
                requestAnimationFrame(() => this.loop());
            }
        };

        class VisualGrain {
            constructor(w, h) {
                this.w = w; this.h = h; this.reset();
            }

            reset() {
                this.x = Math.random() * this.w;
                this.y = Math.random() * this.h;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.size = 2;
                this.active = 0;
            }

            update(touching, tx, ty) {
                if (touching) {
                    const targetX = tx * this.w + (Math.random() - 0.5) * state.params.spray * 200;
                    const targetY = ty * this.h + (Math.random() - 0.5) * state.params.spray * 200;
                    this.x += (targetX - this.x) * 0.1;
                    this.y += (targetY - this.y) * 0.1;
                    this.vx *= 0.8; this.vy *= 0.8;
                } else {
                    this.x += this.vx; this.y += this.vy;
                    if (this.x < 0 || this.x > this.w) this.vx *= -1;
                    if (this.y < 0 || this.y > this.h) this.vy *= -1;
                }
                if (this.active > 0) this.active -= 0.1;
            }

            pulse() { this.active = 1.0; }

            draw(ctx, blur) {
                const size = this.size + (this.active * 4);
                const alpha = 0.3 + (this.active * 0.7);

                if (blur > 2) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size + blur, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
                    ctx.fill();
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.fill();
            }
        }

        function setupInteraction() {
            const start = (e) => {
                if (e.target.closest('.controls-container') || e.target.closest('.header') || e.target.closest('#nav-buttons')) return;
                e.preventDefault();
                state.isTouching = true;
                updateTouch(e);
                document.getElementById('status-text').innerText = "FREEZING";
                document.getElementById('status-text').classList.add('visible');
            };

            const move = (e) => {
                if (!state.isTouching) return;
                e.preventDefault();
                updateTouch(e);
            };

            const end = () => {
                state.isTouching = false;
                Canvas.particles.forEach(p => {
                    p.vx = (Math.random() - 0.5) * 5;
                    p.vy = (Math.random() - 0.5) * 5;
                });
                document.getElementById('status-text').innerText = "DISINTEGRATING";
                setTimeout(() => document.getElementById('status-text').classList.remove('visible'), 1000);
            };

            const updateTouch = (e) => {
                const x = e.touches ? e.touches[0].clientX : e.clientX;
                const y = e.touches ? e.touches[0].clientY : e.clientY;
                state.touchX = x / window.innerWidth;
                state.touchY = y / window.innerHeight;
            };

            document.body.addEventListener('mousedown', start);
            document.body.addEventListener('mousemove', move);
            document.body.addEventListener('mouseup', end);
            document.body.addEventListener('touchstart', start, { passive: false });
            document.body.addEventListener('touchmove', move, { passive: false });
            document.body.addEventListener('touchend', end);

            ['density', 'size', 'spray'].forEach(id => {
                document.getElementById(`param-${id}`).addEventListener('input', (e) => {
                    state.params[id] = parseFloat(e.target.value) / 100;
                    document.getElementById(`val-${id}`).innerText = e.target.value;
                });
            });

            document.getElementById('file-input').addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    Audio.loadBuffer(ev.target.result);
                    document.getElementById('track-name').innerText = file.name.toUpperCase();
                };
                reader.onerror = () => alert("Error reading file.");
                reader.readAsArrayBuffer(file);
            });
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            Audio.init();
            Canvas.init();
            setupInteraction();
            const overlay = document.getElementById('start-overlay');
            overlay.style.opacity = 0;
            setTimeout(() => overlay.remove(), 1000);
            state.isPlaying = true;
        });
    </script>
    <script>
        function randomApp() {
            const apps = ['freosan', 'bryne', 'hrinan', 'ginung', 'druh', 'ceorf', 'bloma', 'mynd', 'hrisian', 'tocnyssan', 'gleobeam', 'gimcynn', 'Sceo', 'Wudubora', 'hlof', 'hearg', 'organistre', 'ablawung', 'afindan', 'sceacel'];
            let random = apps[Math.floor(Math.random() * apps.length)];
            while (window.location.href.includes(random)) {
                random = apps[Math.floor(Math.random() * apps.length)];
            }
            window.location.href = '../' + random + '/';
        }
    </script>








    <!-- MIDI Integration -->
    <script src="../midi-handler.js"></script>
    <script>
        (function () {
            window.addEventListener('load', () => {
                if (!window.MIDIHandler) {
                    console.error("MIDIHandler not found. Check if ../midi-handler.js is accessible.");
                    return;
                }

                // Note Mapping
                window.MIDIHandler.on('noteon', (data) => {
                    if (!state.isPlaying) return; // Global rule: manual init

                    const canvas = document.getElementById('glCanvas');
                    const rect = canvas.getBoundingClientRect();

                    // MIDI X/Y mapping: X=pitch, Y=velocity
                    const x = (data.note / 127) * rect.width;
                    const y = (1 - (data.velocity / 127)) * rect.height;

                    // Update state to simulate touch
                    state.isTouching = true;
                    state.touchX = x / rect.width;
                    state.touchY = y / rect.height;

                    // Display touch status
                    document.getElementById('status-text').innerText = "MIDI FREEZING";
                    document.getElementById('status-text').classList.add('visible');
                });

                window.MIDIHandler.on('noteoff', (data) => {
                    state.isTouching = false;
                    document.getElementById('status-text').classList.remove('visible');

                    Canvas.particles.forEach(p => {
                        p.vx = (Math.random() - 0.5) * 5;
                        p.vy = (Math.random() - 0.5) * 5;
                    });
                });

                // CC Mapping
                window.MIDIHandler.on('cc', (data) => {
                    if (data.controller === 1) { // Mod Wheel -> Master Volume
                        const masterG = Audio.master;
                        if (masterG && masterG.gain) {
                            masterG.gain.setTargetAtTime(data.value / 127, Audio.ctx.currentTime, 0.05);
                        }
                    }
                });
            });
        })();
    </script>
    <!-- /MIDI Integration -->

</body>

</html>