<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Touch rhythm file</title>
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Sans:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #000000;
            --fg-color: #ffffff;
            --accent-color: #333333;
            --font-family: 'Josefin Sans', sans-serif;
        }

        .init-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
            transition: opacity 1.5s ease;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--fg-color);
            font-family: var(--font-family);
            overflow: hidden;
            touch-action: none;

        }

        #app {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;

        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 20px;
            box-sizing: border-box;
        }

        #init-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            cursor: pointer;
            transition: opacity 0.5s ease;
        }

        #init-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #init-text {
            font-size: 24px;
            letter-spacing: 5px;
            text-transform: uppercase;
            font-weight: 300;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.5;
            }
        }

        #loading-text {
            font-size: 14px;
            margin-top: 20px;
            color: #888;
            display: none;
        }

        /* Persistent M/R buttons (centered) */
        #persistent-nav {
            position: fixed;
            top: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            gap: 12px;
            z-index: 10000;
            pointer-events: auto;
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-family: var(--font-family);
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }

        .nav-btn:hover {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        /* Title (left) – hidden initially */
        .title-block {
            position: fixed;
            top: 24px;
            left: 24px;
            text-align: left;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
        }

        .title-main {
            font-weight: 600;
            font-size: 18px;
            letter-spacing: 6px;
            text-transform: uppercase;
        }

        .title-sub {
            font-weight: 300;
            font-size: 10px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #444;
        }

        /* LOAD AUDIO button (right) – hidden initially */
        #file-trigger {
            position: fixed;
            top: 24px;
            right: 24px;
            cursor: pointer;
            font-size: 10px;
            letter-spacing: 2px;
            border: 1px solid #333;
            padding: 8px 16px;
            border-radius: 15px;
            pointer-events: auto;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            transition: all 0.2s;
        }

        #file-trigger:hover {
            border-color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .bottom-controls {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            pointer-events: auto;
            margin-bottom: 0;
        }

        .pattern-indicator {
            display: flex;
            gap: 4px;
        }

        .pattern-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #333;
            transition: all 0.1s;
        }

        .pattern-dot.active {
            background: #fff;
            transform: scale(1.5);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .slider-container {
            width: 80%;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #666;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: var(--fg-color);
            cursor: pointer;
            margin-top: -5px;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: #333;
        }

        #touch-marker {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            z-index: 5;
        }

        #touch-marker.active {
            display: block;
            animation: ripple 1s infinite;
        }

        @keyframes ripple {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.5;
            }

            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <div id="init-overlay">
        <div id="init-text">Touch to Initialise</div>
        <div id="loading-text">Processing Audio...</div>
    </div>

    <input type="file" id="file-input" accept="audio/*" style="display: none;">

    <!-- Persistent M/R buttons (centered) -->
    <div id="persistent-nav">
        <button class="nav-btn" onclick="window.location.href='../index.html'">M</button>
        <button class="nav-btn" onclick="goToRandom()">R</button>
    </div>

    <!-- LOAD AUDIO button (right) – hidden initially -->
    <div id="file-trigger" class="init-hidden">LOAD AUDIO</div>

    <div id="app">
        <!-- Title (left) – hidden initially -->
        <div class="title-block init-hidden">
            <div class="title-main">TOCNYSSAN</div>
            <div class="title-sub">TOUCH RHYTHM SYNTHESISER</div>
        </div>

        <canvas id="visualizer"></canvas>
        <div id="touch-marker"></div>

        <!-- Bottom controls – hidden initially -->
        <div id="ui-layer" class="init-hidden">
            <div class="bottom-controls">
                <div class="pattern-indicator" id="pattern-indicator">
                    <!-- Dots generated by JS -->
                </div>
                <div class="slider-container">
                    <label for="bpm">TEMPO <span id="bpm-val">120</span></label>
                    <input type="range" id="bpm" min="60" max="200" step="1" value="120">
                </div>
            </div>
        </div>
    </div>

    <script>
        let audioCtx;
        let isPlaying = false;
        let isTouching = false;

        let masterGain;
        let analyser;
        let panner;

        let audioBuffer = null;
        let transients = [];
        let isProcessing = false;

        let schedulerTimer;
        let nextNoteTime = 0.0;
        let lookahead = 25.0;
        let scheduleAheadTime = 0.1;
        let noteCount = 0;

        let bpm = 120;

        let density = 90;
        let quantize = 0;
        let filterFreq = 100;
        let filterQ = 0.001;
        let stereoWidth = 0;
        let panVal = 0;

        let currentRate = 16;
        let rateDivider = 4;
        let currentFilterType = 'bandpass';

        // Function to reveal UI elements after initialisation
        function revealUI() {
            document.querySelector('.title-block').classList.remove('init-hidden');
            document.getElementById('file-trigger').classList.remove('init-hidden');
            document.getElementById('ui-layer').classList.remove('init-hidden');
        }

        // Ensure audio graph is set up
        async function initAudio() {
            if (audioCtx) return;

            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                panner = audioCtx.createStereoPanner();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0;

                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;

                panner.connect(masterGain);
                masterGain.connect(analyser);
                analyser.connect(audioCtx.destination);

                console.log('Audio initialized');
            } catch (e) {
                console.error('Audio init failed', e);
            }
        }

        function findTransients(buffer) {
            const channelData = buffer.getChannelData(0);
            const sampleRate = buffer.sampleRate;
            const foundTransients = [];

            const windowSize = Math.floor(sampleRate * 0.01);
            let energyHistory = new Float32Array(100);
            let historyIndex = 0;

            const sensitivity = 1.5;
            const silenceThresh = 0.01;
            const minDistance = Math.floor(sampleRate * 0.05);

            let lastTransient = -minDistance;

            for (let i = 0; i < channelData.length - windowSize; i += windowSize) {
                let sum = 0;
                for (let j = 0; j < windowSize; j++) {
                    sum += channelData[i + j] * channelData[i + j];
                }
                const rms = Math.sqrt(sum / windowSize);

                let historySum = 0;
                for (let k = 0; k < energyHistory.length; k++) historySum += energyHistory[k];
                const historyAvg = historySum / energyHistory.length;

                if (rms > silenceThresh && rms > historyAvg * sensitivity && (i - lastTransient) > minDistance) {
                    foundTransients.push(i / sampleRate);
                    lastTransient = i;
                }

                energyHistory[historyIndex] = rms;
                historyIndex = (historyIndex + 1) % energyHistory.length;
            }

            if (foundTransients.length === 0) {
                foundTransients.push(0);
                for (let t = 0.5; t < buffer.duration; t += 0.5) {
                    foundTransients.push(t);
                }
            }

            return foundTransients;
        }

        const fileInput = document.getElementById('file-input');
        const fileTrigger = document.getElementById('file-trigger');
        const loadingText = document.getElementById('loading-text');
        const initOverlay = document.getElementById('init-overlay');
        const initText = document.getElementById('init-text');

        async function loadAudioFileFromBlob(file) {
            await initAudio(); // ensure context exists

            loadingText.style.display = 'block';
            initText.style.display = 'none';
            loadingText.textContent = "Decoding " + file.name + "...";

            try {
                const arrayBuffer = await file.arrayBuffer();
                const decodedAudio = await audioCtx.decodeAudioData(arrayBuffer);

                audioBuffer = decodedAudio;
                loadingText.textContent = "Analyzing Transients...";

                setTimeout(() => {
                    transients = findTransients(audioBuffer);
                    console.log("Found " + transients.length + " transients");

                    loadingText.style.display = 'none';
                    initText.style.display = 'block';
                    initOverlay.classList.add('hidden');

                    // Reveal UI after file is loaded
                    revealUI();

                    if (!isPlaying) {
                        isPlaying = true;
                        nextNoteTime = audioCtx.currentTime;
                        scheduler();
                    }
                }, 100);

            } catch (err) {
                console.error("Error loading file:", err);
                loadingText.textContent = "Error loading file. Touch to retry.";
                // Allow retry by clicking overlay again
            }
        }

        fileTrigger.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', async (e) => {
            if (e.target.files.length === 0) return;
            const file = e.target.files[0];
            await loadAudioFileFromBlob(file);
        });

        // Load default file only after user clicks the overlay
        initOverlay.addEventListener('click', async () => {
            // If already hidden, do nothing
            if (initOverlay.classList.contains('hidden')) return;

            // Show loading text
            loadingText.style.display = 'block';
            initText.style.display = 'none';

            await initAudio();

            // Attempt to load default Beat.wav
            try {
                const response = await fetch('../Audiofiles/Beat.wav');
                if (!response.ok) throw new Error('File not found');
                const blob = await response.blob();
                const file = new File([blob], 'Beat.wav', { type: blob.type || 'audio/wav' });
                await loadAudioFileFromBlob(file); // this will hide overlay and reveal UI when done
            } catch (e) {
                console.warn('Could not load default Beat.wav', e);
                loadingText.textContent = "No default file. Please LOAD AUDIO.";
                // Keep overlay visible, but allow user to load a file manually
                initText.style.display = 'block';
                loadingText.style.display = 'none';
            }
        });

        const bpmInput = document.getElementById('bpm');
        const bpmVal = document.getElementById('bpm-val');
        const patternIndicator = document.getElementById('pattern-indicator');
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        const touchMarker = document.getElementById('touch-marker');

        function initPatternDots() {
            patternIndicator.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const dot = document.createElement('div');
                dot.className = 'pattern-dot';
                patternIndicator.appendChild(dot);
            }
        }
        initPatternDots();

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function nextNote() {
            const secondsPerBeat = 60.0 / bpm;
            const secondsPer64th = secondsPerBeat / 16;
            nextNoteTime += secondsPer64th;
            noteCount++;
        }

        function getPatternValue(position, channel) {
            const step16 = Math.floor(position / 4) % 16;

            const widthOffset = Math.floor((stereoWidth / 100) * 8);

            const leftPattern = [1.0, 0.2, 0.6, 0.1, 0.8, 0.1, 0.4, 0.3, 0.9, 0.3, 0.7, 0.2, 0.6, 0.4, 0.5, 0.1];
            const rightPattern = [0.1, 0.8, 0.2, 0.7, 0.3, 0.9, 0.1, 0.6, 0.2, 0.7, 0.3, 0.8, 0.4, 0.5, 0.6, 0.2];

            const pattern = channel === 'left' ? leftPattern : rightPattern;
            const shiftedPos = (step16 + (channel === 'right' ? widthOffset : 0)) % 16;
            return pattern[shiftedPos];
        }

        function playFragment(time, channel) {
            if (!audioBuffer || transients.length === 0) return;

            const transientIndex = Math.floor(Math.random() * transients.length);
            const startTime = transients[transientIndex];

            const duration = (60 / bpm / 16) * rateDivider;

            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = currentFilterType;

            const freqRandom = 1.0 + (Math.random() * 0.2 - 0.1);
            filter.frequency.value = Math.max(20, Math.min(20000, filterFreq * freqRandom));
            filter.Q.value = filterQ;

            const gainNode = audioCtx.createGain();

            gainNode.gain.setValueAtTime(0, time);
            gainNode.gain.linearRampToValueAtTime(1.0, time + 0.005);
            gainNode.gain.exponentialRampToValueAtTime(0.01, time + duration);

            const voicePanner = audioCtx.createStereoPanner();

            const widthVal = stereoWidth / 100;
            const randomPan = (Math.random() * 2 - 1) * widthVal;

            if (channel === 'left') {
                voicePanner.pan.value = -0.5 * widthVal;
            } else if (channel === 'right') {
                voicePanner.pan.value = 0.5 * widthVal;
            } else {
                voicePanner.pan.value = randomPan;
            }

            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(voicePanner);
            voicePanner.connect(panner);

            source.start(time, startTime, duration + 0.1);
            source.stop(time + duration + 0.2);

            source.onended = () => {
                source.disconnect();
                filter.disconnect();
                gainNode.disconnect();
                voicePanner.disconnect();
            };
        }

        function scheduleNote(time) {
            if (!isTouching) return;

            if (noteCount % rateDivider !== 0) return;

            const quantizeNorm = quantize / 100;

            const leftValue = getPatternValue(noteCount, 'left');
            const rightValue = getPatternValue(noteCount, 'right');

            const densityNorm = density / 100;

            if (Math.random() < densityNorm * leftValue) {
                playFragment(time, 'left');
            }

            if (Math.random() < densityNorm * rightValue) {
                playFragment(time, 'right');
            }

            if (panner) {
                panner.pan.setTargetAtTime(panVal, time, 0.05);
            }

            updatePatternIndicator();
        }

        function updatePatternIndicator() {
            requestAnimationFrame(() => {
                const step16 = Math.floor(noteCount / 4) % 16;
                const dots = patternIndicator.children;
                for (let i = 0; i < dots.length; i++) {
                    if (i === step16) {
                        dots[i].classList.add('active');
                    } else {
                        dots[i].classList.remove('active');
                    }
                }
            });
        }

        function scheduler() {
            if (!isPlaying) return;
            while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
                scheduleNote(nextNoteTime);
                nextNote();
            }
            schedulerTimer = setTimeout(scheduler, lookahead);
        }

        function updateParamsFromInput(x, y, midiVelocity = null) {
            const centerX = 0.5;
            const centerY = 0.5;

            const dx = x - centerX;
            const dy = y - centerY;

            const dist = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            if (dist < 0.25) {
                rateDivider = 8;
            } else if (dist < 0.45) {
                rateDivider = 4;
            } else if (dist < 0.55) {
                rateDivider = 2;
            } else {
                rateDivider = 1;
            }

            let paramPos = Math.min(dist / 0.5, 1.0);

            density = 90 + (paramPos * 10);

            quantize = Math.floor((1.0 - Math.pow(paramPos, 2)) * 100);

            stereoWidth = 100 - (paramPos * 70);

            if (angle > -Math.PI / 2 && angle <= 0) {
                currentFilterType = 'lowpass';
            } else if (angle > 0 && angle <= Math.PI / 2) {
                currentFilterType = 'bandpass';
            } else if (angle > Math.PI / 2 && angle <= Math.PI) {
                currentFilterType = 'highpass';
            } else {
                currentFilterType = 'notch';
            }

            const angleNorm = (angle + Math.PI) / (2 * Math.PI);

            if (midiVelocity !== null) {
                filterFreq = 50 + (midiVelocity * 10000);
            } else {
                filterFreq = 50 + (angleNorm * 10000);
            }

            if (rateDivider >= 4) {
                filterQ = 0.005 + (Math.random() * 0.015);
            } else {
                filterQ = 0.001 + (paramPos * 0.02);
            }

            panVal = (x * 2) - 1;

            touchMarker.style.left = (x * 100) + '%';
            touchMarker.style.top = (y * 100) + '%';

            touchMarker.style.transform = `translate(-50%, -50%) rotate(${angle}rad)`;
        }

        function startInteraction(e) {
            if (e.target.closest('#file-trigger') || e.target.closest('.bottom-controls')) return;

            // Ensure audio context and graph are ready
            initAudio().then(() => {
                // Reveal UI (title, load button, bottom controls)
                revealUI();

                if (audioCtx.state === 'suspended') audioCtx.resume();

                isTouching = true;
                touchMarker.classList.add('active');

                if (masterGain) {
                    masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
                    masterGain.gain.setTargetAtTime(1.2, audioCtx.currentTime, 0.1);
                }

                handleMove(e);

                if (!isPlaying) {
                    isPlaying = true;
                    nextNoteTime = audioCtx.currentTime;
                    scheduler();
                }
            });
        }

        function endInteraction() {
            isTouching = false;
            touchMarker.classList.remove('active');

            if (masterGain) {
                masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
                masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.2);
            }
        }

        function handleMove(e) {
            if (!isTouching) return;
            if (e.target.closest('#file-trigger') || e.target.closest('.bottom-controls')) return;
            e.preventDefault();

            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const x = clientX / window.innerWidth;
            const y = clientY / window.innerHeight;

            updateParamsFromInput(x, y);
        }

        const app = document.getElementById('app');

        app.addEventListener('mousedown', startInteraction);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', endInteraction);

        app.addEventListener('touchstart', startInteraction, { passive: false });
        app.addEventListener('touchmove', handleMove, { passive: false });
        app.addEventListener('touchend', endInteraction);

        bpmInput.addEventListener('input', (e) => {
            bpm = parseInt(e.target.value);
            bpmVal.textContent = bpm;
            e.stopPropagation();
        });

        document.querySelector('.bottom-controls').addEventListener('mousedown', (e) => e.stopPropagation());
        document.querySelector('.bottom-controls').addEventListener('touchstart', (e) => e.stopPropagation());

        function draw() {
            requestAnimationFrame(draw);
            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const maxR = Math.min(cx, cy);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;

            ctx.beginPath(); ctx.arc(cx, cy, maxR * 0.5, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); ctx.arc(cx, cy, maxR * 0.9, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); ctx.arc(cx, cy, maxR * 1.1, 0, Math.PI * 2); ctx.stroke();

            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + maxR, cy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy + maxR); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx - maxR, cy); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy - maxR); ctx.stroke();

            ctx.lineWidth = 2;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();

            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * canvas.height / 2;

                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);

                x += sliceWidth;
            }

            ctx.stroke();
        }
        draw();

    </script>

    <script>
        function goToRandom() {
            const apps = ['freosan', 'bryne', 'hrinan', 'ginung', 'druh', 'ceorf', 'bloma', 'mynd', 'hrisian', 'tocnyssan', 'gleobeam', 'gimcynn', 'Sceo', 'Wudubora', 'hlof', 'hearg', 'organistre', 'ablawung', 'afindan', 'sceacel'];
            let next = apps[Math.floor(Math.random() * apps.length)];
            while (next === 'tocnyssan') next = apps[Math.floor(Math.random() * apps.length)];
            window.location.href = '../' + next + '/';
        }
    </script>

    <!-- MIDI Integration -->
    <script src="../midi-handler.js"></script>
    <script>
        (function () {
            window.addEventListener('load', () => {
                if (!window.MIDIHandler) {
                    console.error("MIDIHandler not found. Check if ../midi-handler.js is accessible.");
                    return;
                }

                console.log("Setting up MIDI with Centroid Snapping and Integer Mapping for " + document.title);

                // Note Mapping
                window.MIDIHandler.on('noteon', (data) => {
                    if (typeof initAudio !== 'function') return;
                    if (!audioCtx) return; // Global rule: manual init

                    const cx = 0.5;
                    const cy = 0.5;

                    const angle = (data.note / 127) * 2 * Math.PI;
                    const velNorm = data.velocity / 127;
                    const dist = velNorm * 0.5;

                    const x = cx + Math.cos(angle) * dist;
                    const y = cy + Math.sin(angle) * dist;

                    isTouching = true;
                    touchMarker.classList.add('active');

                    if (masterGain) {
                        masterGain.gain.cancelScheduledValues(audioCtx.currentTime);
                        masterGain.gain.setTargetAtTime(1.2, audioCtx.currentTime, 0.1);
                    }

                    updateParamsFromInput(x, y, velNorm);

                    if (!isPlaying) {
                        isPlaying = true;
                        nextNoteTime = audioCtx.currentTime;
                        scheduler();
                    }
                });

                window.MIDIHandler.on('noteoff', (data) => {
                    endInteraction();
                });

                // CC Mapping
                window.MIDIHandler.on('cc', (data) => {
                    if (data.controller === 1) { // Mod Wheel -> Master Volume
                        if (masterGain) {
                            masterGain.gain.setTargetAtTime(data.value / 127, audioCtx.currentTime, 0.05);
                        }
                    }
                });
            });
        })();
    </script>
    <!-- /MIDI Integration -->

</body>

</html>